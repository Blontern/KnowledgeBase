## 背景故事

你正在开发一款回合制游戏的角色状态管理系统。角色在游戏过程中可能处于以下状态之一：

- 待命状态（Idle）：等待指令
- 攻击状态（Attack）：发起攻击
- 防御状态（Defend）：格挡伤害
- 昏迷状态（Stunned）：无法操作

最初你使用如下代码处理角色行为：

```cs
switch (state)
{
    case "Idle": ShowIdleAnimation(); break;
    case "Attack": PerformAttack(); break;
    case "Defend": PerformDefense(); break;
    case "Stunned": DoNothing(); break;
}
```

问题很快显现：

- 每增加一种状态，都要改动多个`switch`块
- 状态逻辑分散，耦合严重，不易扩展维护

你意识到，每种状态都应该拥有**自己的行为**，并在状态变更时切换行为。状态模式正是为此而设计。

## 代码演示

```cs
public interface ICharacterState
{
    void Handle();
}
```

```cs
public class IdleState : ICharacterState
{
    public void Handle() => Console.WriteLine("角色处于待命状态，等待指令...");
}

public class AttackState : ICharacterState
{
    public void Handle() => Console.WriteLine("角色发起攻击！");
}

public class DefendState : ICharacterState
{
    public void Handle() => Console.WriteLine("角色进入防御姿态");
}

public class StunnedState : ICharacterState
{
    public void Handle() => Console.WriteLine("角色被击晕，无法行动");
}
```

```cs
public class Character
{
    private ICharacterState currentState;

    public void SetState(ICharacterState state)
    {
        currentState = state;
    }

    public void Act()
    {
        currentState.Handle();
    }
}
```

客户端

```cs
var warrior = new Character();

warrior.SetState(new IdleState());
warrior.Act();

warrior.SetState(new AttackState());
warrior.Act();

warrior.SetState(new StunnedState());
warrior.Act();
```

## 定义

> **状态模式（State）**：允许对象在内部状态发生改变时，改变其行为。看起来像是修改了它的类。

换句话说，状态模式将状态逻辑封装到独立的类中，并通过上下文类进行行为委托，从而消除状态判断语句。

<import filepath="./UML/20.puml" />

## 应用场景

> 💡**适用场景**：
> - 对象行为依赖于其内部状态，且状态频繁变更
> - 有多个互斥状态，且行为完全不同
> - 状态逻辑复杂，需独立封装维护

状态模式本质上是一种**行为切换机制**，提供面向对象的状态管理能力，是构建**有限状态机（FSM）**的核心工具。

当一个对象的行为随着其状态变化而变化时。适用于状态机模式，如编程语言的解释器、TCP协议的状态机等。

|场景|说明|
|---|---|
|**游戏角色状态管理**|如上例，攻击、防御、晕眩、奔跑等状态行为独立|
|**UI 组件状态机**|如按钮的 hover/active/disabled 状态表现不同行为|
|**表单校验流程**|根据步骤状态进行不同输入校验和交互提示|
|**TCP连接状态转换**|CLOSED → LISTEN → SYN_SENT → ESTABLISHED 等复杂连接状态转换过程|

## 总结

**优点**

- 将状态相关行为封装到状态类中，**职责清晰**
- 状态转换显式，消除冗余的条件判断
- 支持状态行为的扩展和复用

**缺点**

- 类数量增加：每个状态都需创建类
- 状态切换逻辑仍需在上下文中控制，可能分散
- 不适合状态数量过少的场景，可能显得冗余