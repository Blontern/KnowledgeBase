## 背景故事

你正在开发一套请求处理系统，例如游戏中角色受到攻击后，需要依次进行：

- 护甲吸收
- 魔法护盾抵消
- 血量结算
- 状态更新

这些处理逻辑彼此独立、按顺序执行，有些可能中途终止请求（如死亡直接中止后续处理）。此时你可能写出这样的代码：

```cs
void HandleAttack(AttackContext ctx)
{
    if (ctx.Armor > 0) ArmorHandler(ctx);
    if (ctx.Shield > 0) ShieldHandler(ctx);
    if (ctx.Health > 0) HealthHandler(ctx);
}
```

随着逻辑增多，这段代码会变得越来越臃肿。你希望：

- 每个处理逻辑自成一体
- 按顺序自动传递请求
- 可灵活插拔、扩展新的处理器

这正是职责链模式的使命：**将请求的发送者与接收者解耦**，并通过**链式结构**让多个对象都有机会处理请求。

## 代码演示

请求上下文对象

```cs
public class AttackContext
{
    public int Damage { get; set; }
    public int Armor { get; set; }
    public int Shield { get; set; }
    public int Health { get; set; }
}
```

### 抽象处理器类

```cs
public abstract class Handler
{
    protected Handler next;

    public void SetNext(Handler nextHandler)
    {
        this.next = nextHandler;
    }

    public abstract void Handle(AttackContext context);
}
```

具体处理器

```cs
public class ArmorHandler : Handler
{
    public override void Handle(AttackContext ctx)
    {
        if (ctx.Armor > 0)
        {
            int absorbed = Math.Min(ctx.Damage, ctx.Armor);
            ctx.Armor -= absorbed;
            ctx.Damage -= absorbed;
            Console.WriteLine($"护甲吸收了 {absorbed} 点伤害");
        }
        next?.Handle(ctx);
    }
}

public class ShieldHandler : Handler
{
    public override void Handle(AttackContext ctx)
    {
        if (ctx.Shield > 0)
        {
            int absorbed = Math.Min(ctx.Damage, ctx.Shield);
            ctx.Shield -= absorbed;
            ctx.Damage -= absorbed;
            Console.WriteLine($"魔法护盾抵消了 {absorbed} 点伤害");
        }
        next?.Handle(ctx);
    }
}

public class HealthHandler : Handler
{
    public override void Handle(AttackContext ctx)
    {
        ctx.Health -= ctx.Damage;
        Console.WriteLine($"最终造成 {ctx.Damage} 点伤害，剩余血量：{ctx.Health}");
        ctx.Damage = 0;
    }
}
```

客户端

```cs
class Program
{
    static void Main()
    {
	    // 构建职责链
        var armor = new ArmorHandler();
        var shield = new ShieldHandler();
        var health = new HealthHandler();
        armor.SetNext(shield);
        shield.SetNext(health);
		// 按职责链传递顺序处理
        var ctx = new AttackContext
        {
            Damage = 100,
            Armor = 30,
            Shield = 50,
            Health = 200
        };
        armor.Handle(ctx);
    }
}
```

## 定义

> **职责链模式（Chain of Responsibility）**：使多个对象都有机会处理请求，避免请求发送者与接收者的耦合。将这些对象连成一条链，沿着这条链传递请求，直到有一个对象处理它为止。

<import filepath="./UML/13.puml" />

|角色|说明|
|---|---|
|抽象处理器|声明处理接口并持有下一个处理器引用|
|具体处理器|实现请求处理逻辑，可决定是否处理或传递请求|
|客户端|构造责任链并发起请求|

## 应用场景

需要多个对象共同处理请求的场景，处理请求的对象顺序不确定时。

- **UI事件处理系统**：如鼠标点击事件沿组件树上传递，直到被某个组件消费
- **权限校验链**：如认证 → 授权 → 资源控制
- **数据校验链**：如注册表单中，用户名、邮箱、密码校验依次执行

## 总结

优点

- **解耦发送者与接收者**：允许多个处理对象来处理请求，客户端无需知道谁处理请求
- **动态组合处理逻辑**：链式结构易于调整处理顺序
- **符合开闭原则**：添加新处理器无需修改原逻辑

缺点

- **调试困难**：链条过长时，不易定位问题
- **链条中断风险**：若某处理器忘记调用 `next.Handle()`，将中断流程
- **不适合必须全部处理的场景**