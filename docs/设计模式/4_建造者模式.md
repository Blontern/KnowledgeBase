## 背景故事

假设你在开发游戏角色系统，需要创建复杂角色（如战士）。角色由多个部件组成：

- 武器（剑/法杖）
- 盔甲（重甲/皮甲）
- 技能树（近战/远程）
- 外观（肤色/发型）

如果使用传统构造函数进行初始化，例如：`new Character("战士", "巨剑", "板甲", "旋风斩", "北欧", "光头", ...);`

这样做会带来怎样的**问题**：

1. 参数爆炸：构造函数参数过多，调用时容易遗漏或顺序出错
2. 构造逻辑混乱：所有逻辑堆叠在构造函数中，难以阅读和维护
3. 灵活性差：无法按需定制构造过程，例如跳过某些字段或动态组合属性
4. 可选参数处理困难：不能优雅处理可选配置，容易产生大量重载或空参数占位代码

**建造者模式（Builder）** 提供了优雅的解决方式，提升了灵活性与可读性。

## 代码演示

1. 产品类

```cs
public class GameCharacter
{
    public string Name { get; set; }
    public string Weapon { get; set; }
    public string Armor { get; set; }
    public string Skill { get; set; }
    public string Appearance { get; set; }

    public void Display()
    {
        Console.WriteLine($"角色: {Name}, 武器: {Weapon}, 盔甲: {Armor}, 技能: {Skill}, 外观: {Appearance}");
    }
}
```

2. 建造者

```cs
public class CharacterBuilder
{
    private GameCharacter _character = new GameCharacter();

    public CharacterBuilder SetName(string name)
    {
        _character.Name = name;
        return this;
    }

    public CharacterBuilder SetWeapon(string weapon)
    {
        _character.Weapon = weapon;
        return this;
    }

    public CharacterBuilder SetArmor(string armor)
    {
        _character.Armor = armor;
        return this;
    }

    public CharacterBuilder SetSkill(string skill)
    {
        _character.Skill = skill;
        return this;
    }

    public CharacterBuilder SetAppearance(string appearance)
    {
        _character.Appearance = appearance;
        return this;
    }

    public GameCharacter Build() => _character;
}
```

3. 客户端调用

```cs
class Program
{
    static void Main()
    {
		var warrior = new WarriorBuilder()
		    .SetName("战士")
		    .SetWeapon("巨剑")
		    .SetArmor("板甲")
		    .SetSkill("旋风斩")
		    .SetAppearance("北欧风·光头")
		    .Build();

		warrior.Display();
    }
}
```

## 定义

> **建造者模式（Builder）** ：将一个复杂对象的构建过程与其表示方式分离，使得同样的构建过程可以创建不同的表示。

<import filepath="./UML/4.puml" />

## 应用场景

1. 当构造函数的参数过多时
2. 需要链式语法提升可读性时

## 总结

### 优点

- **参数可控**：构建过程清晰，易于理解和维护；
- **构建解耦**：对象构建逻辑与产品类本身解耦；
- **链式调用**：提升代码可读性；
- **灵活组合**：支持按需定制构造流程与默认值；
- **扩展性强**：支持不同构建器构造不同风格产品。
