## 背景故事

假设你在开发一个**图片浏览器**，用户可以预览远程图片。

直接加载远程大图会带来以下问题：

- 首次打开页面加载慢
- 没有缓存机制，重复加载浪费资源
- 用户可能根本不点击图片，却提前加载浪费带宽

你希望：**在真正需要时再去加载远程图片**，并添加权限判断、缓存、统计等功能。但又不想改变原图类的接口。

这时，代理模式就能帮你——**在原对象外部构建一个“替身”，控制访问逻辑**。

## 代码演示

抽象主题接口

```cs
public interface IImage
{
    void Display();
}
```

真实主题类（真实图片）

```cs
public class RealImage : IImage
{
    private string fileName;

    public RealImage(string fileName)
    {
        this.fileName = fileName;
        LoadFromDisk(); // 耗时操作
    }

    private void LoadFromDisk()
    {
        Console.WriteLine($"正在从磁盘加载图片：{fileName}");
    }

    public void Display()
    {
        Console.WriteLine($"显示图片：{fileName}");
    }
}
```

代理类（虚拟代理）

```cs
public class ProxyImage : IImage
{
    private RealImage realImage;
    private string fileName;

    public ProxyImage(string fileName)
    {
        this.fileName = fileName;
    }

    public void Display()
    {
        if (realImage == null)
        {
            realImage = new RealImage(fileName); // 延迟加载
        }
        realImage.Display();
    }
}
```

客户端

```cs
class Program
{
    static void Main()
    {
        IImage image = new ProxyImage("test.png");

        Console.WriteLine("第一次调用 Display()");
        image.Display();

        Console.WriteLine("\n第二次调用 Display()");
        image.Display();
    }
}
```

```
第一次调用 Display()
正在从磁盘加载图片：test.png
显示图片：test.png

第二次调用 Display()
显示图片：test.png
```

## 定义

> **代理模式（Proxy）**：为其他对象提供一种**代理以控制对该对象的访问**，即在访问对象时引入一个中介层，用于附加额外操作，如懒加载、安全控制、缓存、远程通信等。

<import filepath="./UML/11.puml" />

|角色|职责|
|---|---|
|抽象主题（Subject）|定义原始对象与代理类的公共接口|
|真实主题（RealSubject）|实际完成业务功能的类|
|代理类（Proxy）|控制对真实主题的访问，可添加缓存、安全、远程调用等功能|

|类型|功能|应用示例|
|---|---|---|
|虚拟代理|延迟加载，节省资源|图片延迟加载、懒加载资源|
|安全代理|权限控制，防止未授权访问|接口安全检查、权限拦截|
|远程代理|跨进程/网络通信|RPC（如 gRPC、Remoting）|
|缓存代理|记录历史数据、结果复用|数据库查询缓存、接口响应缓存|
|智能代理|执行前后附加操作|日志记录、性能监控、事务控制|

## 应用场景

代理模式适用于**在不改变目标对象的情况下添加额外行为**，本质上是**结构性封装**的一种技巧。

**场景 1：懒加载图像组件**  
节省带宽，延迟加载，用户点击再加载实际图片。

**场景 2：数据库连接池代理**  
控制连接生命周期，防止过度连接消耗。

**场景 3：RPC 服务代理**  
客户端本地方法调用实际上是代理对象，远程执行服务。

**场景 4：接口权限控制**  
敏感方法通过代理判断当前用户权限是否足够。

## 总结

优点
- **控制对象访问**：可限制访问权限、加锁、认证
- **增加系统灵活性**：扩展功能无需修改真实对象
- **支持延迟加载**：节省资源，优化性能
- **隐藏远程实现细节**：屏蔽网络通信复杂度

缺点
- **增加类数量**：一个主题就要一个代理
- **增加系统复杂性**：维护更多中介角色
- **可能引入性能开销**：多一层间接调用