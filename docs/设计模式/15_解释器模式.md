## 背景故事

你或许听过**领域特定语言（DSL）**，一种为特定领域设计的专用语言（如SQL、正则表达式、HTML），有内部(嵌入代码中)和外部(读取脚本文本文档)之分。

这就需要一种机制，将用户定义的语言“翻译”成系统可理解的行为——这正是**解释器模式**的核心。

解释器模式用于为某种语言定义**语法表示**，并构建一个解释器来解释该语言中的句子，适用于 **小型语言或规则系统** 的构建，是构建 DSL（领域专用语言） 的经典手段之一。


## 代码演示

我们实现一个简单的布尔表达式语言：

抽象表达式接口

```cs
public interface IExpression
{
    bool Interpret();
}
```

终结符表达式，最小单位，如：常量、变量等

```cs
public class BooleanLiteral : IExpression
{
    private readonly bool _value;

    public BooleanLiteral(bool value) => _value = value;

    public bool Interpret() => _value;
}
```

非终结符表达式，即运算表达式，如：加法、逻辑、条件等

```cs
public class AndExpression : IExpression
{
    private readonly IExpression _left, _right;

    public AndExpression(IExpression left, IExpression right)
    {
        _left = left; _right = right;
    }

    public bool Interpret() => _left.Interpret() && _right.Interpret();
}

public class OrExpression : IExpression
{
    private readonly IExpression _left, _right;

    public OrExpression(IExpression left, IExpression right)
    {
        _left = left; _right = right;
    }

    public bool Interpret() => _left.Interpret() || _right.Interpret();
}
```

客户端构建表达式

```cs
class Program
{
    static void Main()
    {
        // 表达式：(true or false) and true
        IExpression expr = new AndExpression(
            new OrExpression(
                new BooleanLiteral(true),
                new BooleanLiteral(false)
            ),
            new BooleanLiteral(true)
        );

        Console.WriteLine(expr.Interpret()); // 输出: true
    }
}
```

姑且可以当作内部SDL使用，但功能还不完善，该设计可以进一步封装为 DSL，或结合语法树解析器使用，变成外部DSL。

## 定义

**解释器模式（Interpreter）**：给定一门语言，定义其文法的一种表示，并定义一个解释器，用于解释语言中的句子。

<import filepath="./UML/15.puml" />

## 应用场景

解释器模式适用于**具有固定文法结构的语言解析需求**：

- 数学表达式求值器
- 简易脚本语言引擎
- SQL/DSL 查询解析器
- 游戏指令系统（如 RPG 指令树）
- 配置规则、条件过滤器解析

## 总结

优点

- 易于扩展语法：每新增表达式只需实现新类
- 可构建自定义语言（DSL）
- 解释逻辑与语法结构解耦

缺点

- 类数量增多：每个规则都要新建类
- 性能低：大量嵌套对象解释，效率不如语法分析器
- 不适用于复杂语法（建议用 ANTLR、Lark、PEG）