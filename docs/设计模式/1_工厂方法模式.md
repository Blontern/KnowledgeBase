## 背景故事

在使用简单工厂模式后，你发现每新增一种产品（如门的种类），都要**修改工厂类本身**，这显然违反了开闭原则（对扩展开放，对修改关闭）。

于是你开始思考，有没有更优雅的方式，在不修改现有代码的前提下添加新产品？这正是工厂方法模式解决的问题！

它就像连锁加盟店的模式：

- **总部**（抽象工厂）：统一规范与接口
- **分店**（具体工厂）：按需独立生产具体产品

新增产品只需开设“分店”，不必改动总部逻辑。

### 模式对比

首先，我们来对比以下两个模式结构上有什么区别。

简单工厂模式：

<import filepath="./UML/0.puml"/>

工厂方法模式：

<import filepath="./UML/1.puml" />

工厂方法通过对工厂类本身进行抽象，**将具体产品的创建延迟到子类中完成**，避免了修改总工厂类，符合开闭原则。

## 代码演示

1. 抽象工厂接口与具体工厂类

```cs [对工厂类抽象]
// 抽象工厂接口
interface IDoorFactory
{
    DoorBase CreateDoor(float width, float height);
}
// 木门工厂
public WoodenDoorFactory : IDoorFactory{
    DoorBase CreateDoor(width, height){
	    return new WoodenDoor(width, height);
  }
}
// 铁门工厂
public IronDoorFactory : IDoorFactory{
    DoorBase CreateDoor(width, height){
	    return new IronDoor(width, height);
  }
}
```

2. 客户端对比

使用简单工厂：

```cs [客户端(使用简单工厂模式)]
using DoorFactory;
static void Main(string[] args)
{
    DoorBase door1 = DoorFactory.CreateDoor("wooden", 90, 210);
    door1.Open();

    DoorBase door2 = DoorFactory.CreateDoor("iron", 110, 230);
    door2.Open();
}
```

使用工厂方法模式：

```cs [客户端(使用工厂方法模式)]
using IDoorFactory;
using DoorBase;
using WoodenDoorFactory;
using IronDoorFactory;
static void Main(string[] args)
{
    // 使用木门工厂
    IDoorFactory woodenFactory = new WoodenDoorFactory();
    DoorBase woodenDoor = woodenFactory.CreateDoor(90, 210);
    woodenDoor.Open();
    // 使用铁门工厂
    IDoorFactory ironFactory = new IronDoorFactory();
    DoorBase ironDoor = ironFactory.CreateDoor(110, 230);
    ironDoor.Open();
}
```

3. 通过自动类型推断简化代码

```cs [客户端(使用工厂方法模式)]
using IDoorFactory; // [!code --]
using DoorBase; // [!code --]
using WoodenDoorFactory;
using IronDoorFactory;
static void Main(string[] args)
{
    // 使用木门工厂
    IDoorFactory woodenFactory = new WoodenDoorFactory(); // [!code --]
    var woodenFactory = new WoodenDoorFactory(); // 自动推断 [!code ++]
    DoorBase woodenDoor = woodenFactory.CreateDoor(90, 210); // [!code --]
    var woodenDoor = woodenFactory.CreateDoor(90, 210); // 自动推断 [!code ++]
    woodenDoor.Open();
    // 使用铁门工厂
    IDoorFactory ironFactory = new IronDoorFactory(); // [!code --]
    var ironFactory = new IronDoorFactory(); // 自动推断 [!code ++]
    DoorBase ironDoor = ironFactory.CreateDoor(110, 230); // [!code --]
    var ironDoor = ironFactory.CreateDoor(110, 230); // 自动推断 [!code ++]
    ironDoor.Open();
}
```

明确类型更有助于理解，所以在重要的代码段落尽量不要使用自动推断。

## 定义

> **工厂方法模式（Factory Method）**： 定义一个用于创建对象的接口，让子类决定实例化哪一个类。使类的实例化延迟到子类完成。

| 角色         | 作用                         | 客户端是否可见 |
| ------------ | ---------------------------- | -------------- |
| **抽象产品** | 定义产品接口                 | 不可见         |
| **具体产品** | 实现抽象产品的具体类         | 不可见         |
| **抽象工厂** | 声明工厂方法（返回抽象产品） | 可暴露         |
| **具体工厂** | 实现工厂方法（返回具体产品） | 可调用         |

<import filepath="./UML/1.puml" />

## 应用场景

从结构上来看，工厂方法确实解决了简单工厂违反开闭原则的问题。但从结果上看，大部分能用简单工厂实现的结构改用工厂方法都是画蛇添足。

工厂方法模式在以下几种场景中才真正体现其价值：

1. **类层次结构需要开放扩展，而不能修改已有工厂**

- **关键点**：你无法修改已有的工厂类来新增产品类型（例如，工厂类来自外部库，或在框架层中已被冻结）。
- **应用举例**：
  - 插件系统：用户通过继承基础工厂，自行注册并创建自定义组件。
  - 第三方框架扩展：不能改框架源代码，只能扩展。

2. **每个“工厂子类”需要控制“产品”的创建细节**

- **关键点**：产品的创建逻辑不是简单的 `new`，而是**每个具体子类有不同的配置、依赖、资源准备过程**。为了避免单个工厂超级臃肿，只能做出拆分。
- **应用举例**：
  - UI 控件库：每个平台控件创建过程不同，如 WinButton vs MacButton。
  - 游戏角色：不同敌人或角色需要不同的初始化动画、状态机、资源等。
  - 导出格式器工厂（PDFFactory、MarkdownFactory）各自负责一种格式。

## 总结

优点

- 完全遵守开闭原则，扩展性强
- 通过工厂接口实现产品解耦
- 适配多态机制，增强扩展能力

缺点

- 类爆炸问题：每新增一种产品，都需创建新的产品类和工厂类
- 创建逻辑过于分散：集中管理难度上升，不利于统一控制

工厂方法模式适合产品类型需要频繁扩展的场景。

在下次教程中，我们将探讨更强大的**抽象工厂模式**，这也是设计模式的最后要讲的一个工厂了。

| 相关模式     | 特点                                     | 适用场景                           |
| ------------ | ---------------------------------------- | ---------------------------------- |
| 简单工厂模式 | 工厂类内部判断创建逻辑，新增需改代码     | 产品种类少，变化频率低             |
| 工厂方法模式 | 每种产品对应一个子工厂类，新增无需改旧类 | 产品种类多，需支持扩展             |
| 抽象工厂模式 | 创建多个关联产品（产品族）               | 保证系列产品一致性，如整套 UI 组件 |
