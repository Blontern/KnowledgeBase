## 背景故事

你在开发一个**多媒体播放器系统**，模块分布如下：

- `VideoDecoder`：视频解码模块
- `AudioDecoder`：音频解码模块
- `SubtitleRenderer`：字幕渲染模块
- `ScreenManager`：屏幕控制模块

当你播放视频时，调用流程如下：

```cs
videoDecoder.Decode();
audioDecoder.Decode();
subtitleRenderer.Render();
screenManager.Refresh();

```

每次播放一个视频都要重复以上调用，**客户端代码冗长且耦合严重**。更糟的是，如果某个模块变更，所有客户端代码都得跟着改。

这时候，我们希望：
- 将复杂子系统包装在一个简单接口中
- 客户端只需调用统一入口，降低学习成本和调用成本

这正是**外观模式**的价值。

## 代码演示

1. 子系统类（不对外暴露）

```cs
public class VideoDecoder
{
    public void Decode() => Console.WriteLine("视频解码完成");
}

public class AudioDecoder
{
    public void Decode() => Console.WriteLine("音频解码完成");
}

public class SubtitleRenderer
{
    public void Render() => Console.WriteLine("字幕渲染完成");
}

public class ScreenManager
{
    public void Refresh() => Console.WriteLine("屏幕刷新完成");
}
```

2. 外观类（统一入口）

```cs
public class MediaFacade
{
    private readonly VideoDecoder _video = new();
    private readonly AudioDecoder _audio = new();
    private readonly SubtitleRenderer _subtitle = new();
    private readonly ScreenManager _screen = new();

    public void PlayMedia()
    {
        _video.Decode();
        _audio.Decode();
        _subtitle.Render();
        _screen.Refresh();
        Console.WriteLine("媒体播放完成！");
    }
}
```

3. 客户端调用

```cs
static void Main()
{
    MediaFacade media = new MediaFacade();
    media.PlayMedia();  // 一行代码完成多模块调用
}
```

## 定义

> **外观模式（Facade）**：为子系统中的一组接口提供一个**统一的高层接口**，使子系统更易使用，客户端无需直接访问子系统内部类。

<import filepath="./UML/10.puml" />

## 应用场景

需要将复杂进行封装，让外观看上去干干净净的情况下：启动或初始化流程封装、第三方开发工具封装、为子系统提供一个统一的接口。

## 总结

优点
- 客户端只需关注外观接口，**简化使用复杂系统**
- 子系统独立性增强（客户端与子系统解耦）
- 满足迪米特法则（最少知道原则）：只与直接朋友交互

缺点
- 滥用封装可能会引入不必要的抽象，降低系统灵活性
- 若系统频繁变化，外观也要跟着频繁调整