## 背景故事

你正在开发一个**角色属性面板系统**。当角色生命值变化时，多个组件需要同步更新：

- **血条UI**刷新显示
- **日志记录器**记录变更
- **音效系统**触发提示音
- **AI模块**根据血量决定逃跑或追击

如果在`Role`类中手动调用所有这些模块的更新方法，那么一旦新增或删除模块，都要改动`Role`代码 —— 这违背了开闭原则。

观察者模式提供了一种优雅的方式：**发布-订阅机制**。对象状态变更时，通知所有已注册的观察者即可，无需知道谁在监听。

## 代码演示

接口

```cs
public interface IObserver
{
    void Update(int hp);
}

public interface ISubject
{
    void AddObserver(IObserver observer);
    void RemoveObserver(IObserver observer);
    void Notify();
}
```

被观察主体

```cs
public class Role : ISubject
{
    private List<IObserver> observers = new();
    private int hp;

    public void SetHP(int newHp)
    {
        hp = newHp;
        Notify();
    }

    public void AddObserver(IObserver observer) => observers.Add(observer);
    public void RemoveObserver(IObserver observer) => observers.Remove(observer);

    public void Notify()
    {
        foreach (var obs in observers)
            obs.Update(hp);
    }
}
```

观察者

```cs
public class HPBar : IObserver
{
    public void Update(int hp) => Console.WriteLine($"血条更新：当前HP为 {hp}");
}

public class SoundEffect : IObserver
{
    public void Update(int hp)
    {
        if (hp < 30)
            Console.WriteLine("播放低血量警告音效！");
    }
}
```

```cs
var role = new Role();
role.AddObserver(new HPBar());
role.AddObserver(new SoundEffect());

role.SetHP(100);
role.SetHP(25);
```

## 定义

> **观察者模式（Observer）**：定义对象间一对多的依赖关系，使得当一个对象状态发生改变时，所有依赖它的对象都会自动收到通知并更新。

<import filepath="./UML/19.puml" />

## 应用场景

需要建立一种一对多的依赖关系，当一个对象的状态变化时，其他依赖对象需要自动更新的情况。

- **微信公众号订阅**：读者（观察者）订阅公众号（主题），每次推送自动通知所有订阅者。
- **股市行情系统**：多个终端监听某只股票价格变化，实时更新。
- **GUI事件系统**：按钮被点击时，自动通知注册的回调方法。

## 总结

**优点**

- 实现**对象间的松耦合**（发布者无须了解订阅者）
- 支持动态注册/取消监听
- 适配**事件驱动架构**

**缺点**

- 若观察者过多，**通知链较长**，可能引发性能问题
- 通知顺序不确定，需防止“监听依赖”问题
- 不当使用易造成“**隐式依赖混乱**”