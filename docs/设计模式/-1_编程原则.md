## 一、 核心设计原则

1. **DRY - Don't Repeat Yourself (不要重复自己)**

   - **核心：**  同一知识或逻辑在系统中只应有一个明确、权威的表达。
   - **实践：**  通过函数、类、模块、库等方式封装重复代码。避免多处维护相同逻辑，减少错误风险，提高修改效率。

2. **KISS - Keep It Simple, Stupid (保持简单直接)**

   - **核心：**  设计应尽可能简单。避免不必要的复杂性。
   - **实践：**  用清晰、直接的方式解决问题。避免过度设计、过度抽象。简单的代码更容易理解、调试和维护。

3. **YAGNI - You Aren't Gonna Need It (你不会需要它)**

   - **核心：**  不要为未来可能（但不一定）需要的功能添加代码。
   - **实践：**  专注于当前明确的需求。只在需要时才添加功能。避免提前做过多设计导致代码臃肿、难以理解和维护。

4. **SOLID 原则 (面向对象设计的五大支柱)**

   - **S - Single Responsibility Principle (单一职责原则):**  一个类应该只有一个引起它变化的原因。即一个类只负责一项职责。
   - **O - Open/Closed Principle (开闭原则):**  软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。即通过添加新代码（如继承、组合）来扩展功能，而非修改现有代码。
   - **L - Liskov Substitution Principle (里氏替换原则):**  子类型必须能够替换掉它们的基类型。即程序中基类出现的地方，都可以用其子类替换，且程序行为正确。
   - **I - Interface Segregation Principle (接口隔离原则):**  不应该强迫客户端依赖它们不使用的接口。应创建多个特定功能的接口，而非一个庞大臃肿的接口。
   - **D - Dependency Inversion Principle (依赖倒置原则):**  高层模块不应该依赖低层模块，两者都应该依赖其抽象（接口或抽象类）。抽象不应依赖细节，细节应依赖抽象。这促进了松耦合和可测试性。

5. **关注点分离 (Separation of Concerns - SoC)**

   - **核心：**  将程序分解为不同的部分，每个部分解决一个特定的关注点（如用户界面、业务逻辑、数据访问）。
   - **实践：**  使用分层架构（如 MVC, MVVM）、模块化设计。提高代码组织性、可理解性和可维护性。

## 二、 代码质量与可维护性原则

6. **高内聚，低耦合 (High Cohesion, Low Coupling)**

   - **高内聚：**  模块内部元素（函数、数据）紧密相关，共同完成一个明确的目标。
   - **低耦合：**  模块之间相互依赖的程度尽可能低，一个模块的变化对其他模块影响最小。
   - **实践：**  设计模块/类时专注于单一职责，通过定义清晰的接口来限制模块间的交互。

7. **Law of Demeter (迪米特法则 / 最少知识原则)**

   - **核心：**  一个对象应该只与其“朋友”（直接朋友：成员变量、方法参数、方法内部创建的对象）通信，不要与“陌生人”通信。避免  `a.getB().getC().doSomething()`  这样的链式调用。
   - **实践：**  通过封装，让对象提供完成其职责所需的方法，避免暴露过多的内部结构。减少依赖，提高模块独立性。

8. **防御式编程 (Defensive Programming)**

   - **核心：**  假设外部输入、依赖组件或环境可能出现问题，编写代码以优雅地处理错误、无效输入或意外情况。
   - **实践：**  参数校验、空指针检查、异常处理、断言、输入过滤、使用不变式。提高代码的健壮性和容错性。

9. **代码可读性至上 (Code Readability is Paramount)**

   - **核心：**  代码首先是给人读的，其次才是给机器执行的。清晰的代码是维护的基础。
   - **实践：**  使用有意义的命名、保持一致的代码风格、适当的注释（解释“为什么”而非“是什么”）、避免过于复杂的表达式、合理的代码结构（缩进、空行）、遵循团队代码规范。

## 三、 性能与效率原则

10. **避免过早优化 (Avoid Premature Optimization)**

    - **核心：**  在代码清晰、正确且被证明是性能瓶颈之前，不要进行复杂的优化。
    - **实践：**  先编写清晰、正确的代码。使用性能分析工具定位真正的瓶颈，然后有针对性地优化。盲目优化往往损害可读性和可维护性，且效果甚微。

11. **性能与可读性/可维护性的平衡 (Balance Performance and Readability/Maintainability)**

    - **核心：**  在追求性能时，不应过度牺牲代码的清晰度和可维护性。
    - **实践：**  在关键路径上，如果清晰写法确实带来显著性能损失，才考虑优化写法，但务必添加清晰注释说明原因。优先选择算法和数据结构优化。

## 四、 抽象与封装

12. **抽象原则 (Abstraction Principle)**

    - **核心：**  隐藏复杂的实现细节，只暴露必要的接口或概念。
    - **实践：**  使用接口、抽象类、访问修饰符（如  `private`, `protected`）。使用者只需知道“做什么”，无需知道“怎么做”。降低复杂度，提高复用性。

13. **封装 (Encapsulation)**

    - **核心：**  将数据和操作数据的方法绑定在一起，并控制对数据的访问。
    - **实践：**  将数据成员设为  `private`，通过公共的  `getter/setter`  方法或行为方法来访问和修改数据。保护对象内部状态不被意外修改，保证数据完整性。

## 五、 其他重要原则

14. **约定优于配置 (Convention over Configuration - CoC)**

    - **核心：**  框架或库提供一套合理的默认约定，开发者只需在偏离约定时才进行显式配置。
    - **实践：**  减少样板代码和配置文件量（如 Rails, Spring Boot）。提高开发效率。

15. **不要自我重复 (避免“魔数”) (Avoid Magic Numbers/Strings)**

    - **核心：**  避免在代码中直接使用没有明确含义的字面量（数字、字符串）。
    - **实践：**  使用命名良好的常量或枚举类型代替。提高代码可读性和可维护性（修改一处即可）。

16. **正交性原则 (Principle of Orthogonality)**

    - **核心：**  系统中的组件或概念应尽可能相互独立（正交），改变一个不影响另一个。
    - **实践：**  设计功能独立的模块、API。减少副作用，提高系统的可组合性和可预测性。

**总结：**

这些原则不是僵化的教条，而是指导思想和最佳实践。在实际编程中，需要根据具体场景、项目规模、团队经验和需求进行权衡和灵活应用。理解这些原则背后的“_为什么_”（Why）比死记硬背“_是什么_”（What）更重要。它们共同的目标是帮助开发者构建更健壮、更灵活、更易理解和更易维护的软件系统。始终记住：**清晰、简单、可维护的代码是最高优先级**。
