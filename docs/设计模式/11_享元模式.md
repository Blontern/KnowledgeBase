## 背景故事

假设你正在开发一个**大型地图系统**，需要渲染上百万棵树。每棵树都有：

- 样式（形状、颜色、纹理等）
- 坐标（x, y）
- 生长状态（是否结果、健康值）

如果为每棵树都创建一个完整对象，将造成巨大内存浪费（特别是样式信息重复度极高）。

这时，我们可以将**重复不变的部分提取为共享对象**，只存储每棵树的**坐标等变化信息**，从而显著减少内存消耗。这就是享元模式解决的问题。

## 代码演示

抽象享元类

```cs
public interface ITree
{
    void Display(int x, int y);  // 外部状态由客户端提供
}
```

具体享元类（可共享）

```cs
public class TreeType : ITree
{
    private string type;
    private string texture;
    private string color;

    public TreeType(string type, string texture, string color)
    {
        this.type = type;
        this.texture = texture;
        this.color = color;
    }

    public void Display(int x, int y)
    {
        Console.WriteLine($"在({x},{y})显示{type}：颜色={color}，纹理={texture}");
    }
}
```

享元工厂

```cs
public class TreeFactory
{
    private Dictionary<string, TreeType> _treePool = new();

    public TreeType GetTreeType(string type, string texture, string color)
    {
        string key = $"{type}-{texture}-{color}";

        if (!_treePool.ContainsKey(key))
        {
            _treePool[key] = new TreeType(type, texture, color);
        }

        return _treePool[key];
    }

    public int GetTreeTypeCount() => _treePool.Count;
}
```

客户端

```cs
static void Main()
{
	TreeFactory factory = new TreeFactory();

	for (int i = 0; i < 1_000_000; i++)
	{
		var tree = factory.GetTreeType("苹果树", "叶子纹理", "绿色");
		int x = Random.Shared.Next(0, 1000);
		int y = Random.Shared.Next(0, 1000);
		tree.Display(x, y);
	}

	Console.WriteLine($"享元对象总数: {factory.GetTreeTypeCount()}"); // 应仅创建1个TreeType
}
```

## 定义

> **享元模式（Flyweight）**：运用**共享技术**来支持大量细粒度对象的复用，节省系统资源。将状态分为**内部状态**（可共享）与**外部状态**（不可共享），前者存于享元对象中，后者由客户端维护。

<import filepath="./UML/11.puml" />

## 应用场景

凡是有大规模或大体积的相似对象，都可以用以此节约内存。

## 总结

优点
- **极大节省内存**：尤其适用于大规模对象场景（如地图、游戏）
- **共享池集中管理**：对象复用，创建/销毁成本低
- **高性能并发友好**：可用于缓存或对象池管理

缺点
- **逻辑复杂度提升**：状态区分（内部/外部）需清晰明确
- **程序结构变化大**：需引入共享池和访问层
- **非共享属性管理困难**：外部状态需由客户端控制