## 背景故事

你正在开发一个聊天室应用，初始设计如下：

- 每个用户都维护一份“联系人列表”
- 用户之间直接互发消息

问题很快出现了：

- 每新增一个用户，所有已有用户都要更新联系列表，**耦合度爆炸**
- 多个模块之间**互相引用**，让系统如同“毛线团”
- 任意两个对象之间的通信都像“多对多关系”

为了解耦模块之间的通信，你引入了一个“中介者”：聊天室（`ChatRoom`）

中介者负责统一协调各模块之间的交互，对象之间不再直接通信，而是通过中介者来完成交互逻辑。这就是**中介者模式**。

## 代码演示

抽象中介者

```cs
public interface IChatRoom
{
    void SendMessage(string from, string to, string message);
}
```

具体中介者

```cs
public class ChatRoom : IChatRoom
{
    private Dictionary<string, User> _users = new();

    public void Register(User user)
    {
        if (!_users.ContainsKey(user.Name))
            _users[user.Name] = user;

        user.SetChatRoom(this);
    }

    public void SendMessage(string from, string to, string message)
    {
        if (_users.TryGetValue(to, out var user))
        {
            user.Receive(from, message);
        }
    }
}
```

用户类（User）

```cs
public class User
{
    public string Name { get; }
    private IChatRoom _chatRoom;

    public User(string name) => Name = name;

    public void SetChatRoom(IChatRoom chatRoom) => _chatRoom = chatRoom;

    public void Send(string to, string message)
        => _chatRoom.SendMessage(Name, to, message);

    public void Receive(string from, string message)
        => Console.WriteLine($"{from} 对 {Name} 说：{message}");
}
```

客户端使用

```cs
class Program
{
    static void Main()
    {
        var chatRoom = new ChatRoom();

        var alice = new User("Alice");
        var bob = new User("Bob");

        chatRoom.Register(alice);
        chatRoom.Register(bob);

        alice.Send("Bob", "Hi Bob!");
        bob.Send("Alice", "Hello Alice!");
    }
}
```

## 定义

**中介者模式（Mediator）**：用一个中介对象封装一系列对象之间的交互，使各对象不再显式引用彼此，从而降低耦合度，便于独立复用和维护。

<import filepath="./UML/17.puml" />

## 应用场景

1. **多个对象互相通信**导致系统网状耦合（如聊天室、消息总线）
2. 控件之间存在大量复杂交互（GUI 中按钮与输入框交互）
3. 模块之间需要解耦通信逻辑，如 MVC 中控制器作为中介者

## 总结

优点

- 降低对象之间的**耦合度**，集中管理交互逻辑
- 更易于**维护、扩展**，修改通信规则只需改中介者
- 系统结构更加清晰

缺点

- 中介者可能变成“**上帝对象**”，承担过多职责
- 所有交互逻辑集中后，**复杂度转移到中介者**