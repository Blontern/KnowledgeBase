## 背景故事

假如，你要为 Windows、MacOS、Android 三个平台开发跨平台 UI 库，包含按扭、文本框、图片框、标签、表格等数十个控件。

这样就面临一个典型问题：

- **控件数量多**：排列组合，共三十个控件类
- **控件之间有关联性**：同属一个平台，应具备一致风格

使用简单工厂或工厂方法虽然可分别解决对象创建的问题，但它们**无法系统性保障产品之间的兼容性与一致性**。

此时，**抽象工厂模式**便是理想选择：实际上，抽象工厂模式就是在工厂模式抽象了工厂类的基础上，又抽象了产品类。通过抽象工厂类和抽象产品类，规范了创建。

## 代码演示

为便于观看，我们仅为 Windows、MacOS 两个平台分别创建按扭、文本框两种控件。

<import filepath="./UML/2.puml"/>

1. 抽象产品族接口

```cs [抽象产品族]
public interface IButton
{
    void Render();
}

public interface ITextBox
{
    void Input(string text);
}
```

2. 具体产品族实现

```cs [产品族]
public class WindowsButton : IButton
{
    public void Render()
        => Console.WriteLine("渲染Windows风格按钮");
}

public class WindowsTextBox : ITextBox
{
    public void Input(string text)
        => Console.WriteLine($"Windows文本框输入: {text}");
}
```

```cs
public class MacButton : IButton
{
    public void Render()
        => Console.WriteLine("渲染macOS风格按钮");
}

public class MacTextBox : ITextBox
{
    public void Input(string text)
        => Console.WriteLine($"macOS文本框输入: {text}");
}
```

3. 抽象工厂接口

```cs [抽象工厂]
public interface IGUIFactory
{
    IButton CreateButton();
    ITextBox CreateTextBox();
}
```

4. 具体工厂实现

```cs [具体工厂]
public class WindowsFactory : IGUIFactory
{
    public IButton CreateButton() => new WindowsButton();
    public ITextBox CreateTextBox() => new WindowsTextBox();
}
public class MacFactory : IGUIFactory
{
    public IButton CreateButton() => new MacButton();
    public ITextBox CreateTextBox() => new MacTextBox();
}
```

5. 客户端：通过工厂生成整套组件

```cs [客户端]
// 组件仅为便于理解而做出的封装
class Application
{
    private IButton _button;
    private ITextBox _textBox;

    public Application(IGUIFactory factory)
    {
        // 工厂创建风格一致的产品
        _button = factory.CreateButton();
        _textBox = factory.CreateTextBox();
    }

    public void Run()
    {
        _button.Render();
        _textBox.Input("Hello World");
    }
}

class Program
{
    static void Main()
    {
        IGUIFactory factory;

        // 根据配置选择整套UI风格
        string osType = ConfigurationManager.AppSettings["OS"];

		factory = osType switch
        {
            "Windows" => new WindowsFactory(),
            "macOS" => new MacFactory(),
            _ => throw new Exception("不支持的操作系统类型")
        };

        var app = new Application(factory);
        app.Run();
    }
}
```

整套产品的创建交由工厂负责，客户端只需传入工厂，无需了解具体组件类。

### 优化

在基础实现中，客户端需要显式判断操作系统类型并实例化具体工厂，这存在两个明显问题：

1. **违反开闭原则**：新增产品族（如 Linux）需修改客户端代码
2. **工厂创建逻辑重复**：若多处需创建 UI 组件，需重复编写判断逻辑

为此，我们通过两种方式优化架构：

#### 1. 结合简单工厂模式

创建工厂提供者封装对象创建逻辑，客户端只需指定产品族类型：

```cs [工厂提供者]
public static class GUIFactoryProvider
{
    public static IGUIFactory GetFactory(string osType)
    {
        return osType switch
        {
            "Windows" => new WindowsFactory(),
            "macOS" => new MacFactory(),
            _ => throw new Exception("不支持的操作系统")
        };
    }
}
```

```cs [客户端]
class Program
{
    static void Main()
    {
        var osType = ConfigurationManager.AppSettings["OS"];
        var factory = GUIFactoryProvider.GetFactory(osType);
        var app = new Application(factory);
        app.Run();
    }
}
```

**优势**：

- 将创建逻辑集中到单一位置
- 客户端与具体工厂解耦
- 新增产品族只需修改工厂提供者

#### 2. 反射实现动态扩展

通过反射+配置文件实现完全解耦，新增产品族无需修改任何代码：

```cs
public static class DynamicGUIFactory
{
    public static IGUIFactory CreateFactory()
    {
        var osType = ConfigurationManager.AppSettings["OS"];
        var factoryName = ConfigurationManager.AppSettings[$"{osType}Factory"];

        // 反射动态创建实例
        var factoryType = Type.GetType(factoryName);
        return (IGUIFactory)Activator.CreateInstance(factoryType);
    }
}
```

```cs [客户端]
class Program
{
    static void Main()
    {
		var factory = DynamicGUIFactory.CreateFactory();
		var app = new Application(factory);
        app.Run();
    }
}
```

## 定义

> **抽象工厂模式（Abstract Factory）** ：提供一个接口，用于创建**相关或依赖对象的家族**，而无需指定具体类。

| 角色           | 作用                       | 对客户端关系 |
| -------------- | -------------------------- | ------------ |
| **抽象产品族** | 声明产品家族接口           | 不可见       |
| **具体产品族** | 实现特定风格产品           | 不可见       |
| **抽象工厂**   | 声明创建产品家族的方法     | 可暴露       |
| **具体工厂**   | 实现特定产品家族的创建逻辑 | 可调用       |

<import filepath="./UML/2.puml"/>

## 应用场景

抽象工厂特别适用于需要**创建多个关联产品对象**且要求它们之间风格、行为一致的系统，典型应用包括：

1. **数据库访问套件**：`IDbFactory`创建连接对象(Connection)、命令对象(Command)等配套组件，支持 MySQL/Oracle 等数据库全家桶
2. **游戏主题套装**：`IThemeFactory`生成配套的士兵、建筑、植被等资源，快速切换中世纪/科幻主题
3. **跨平台系统**：`FileSystemFactory`创建路径解析器+文件读取器+权限检查器，适配 Windows/Linux 文件系统差异

## 总结

优点

- 保证产品风格**一致性/兼容性**：同一工厂创建的组件具有统一设计语言；
- 客户端**高度解耦**：只依赖抽象接口，不依赖具体实现类；
- 实现**整套产品的切换**：通过替换工厂，一行代码切换整套组件。

缺点

- **扩展产品种类较难**：添加新组件（如下拉框）需要修改所有工厂；
- **类数量膨胀**：n 个产品族 _ m 个产品种类 = n _ m 个具体类 + n+m 个抽象类
- **设计难度较高**：需事先规划好产品族结构及其演进。

| 相关模式     | 特点                                     | 适用场景                           |
| ------------ | ---------------------------------------- | ---------------------------------- |
| 简单工厂模式 | 工厂类内部判断创建逻辑，新增需改代码     | 产品种类少，变化频率低             |
| 工厂方法模式 | 每种产品对应一个子工厂类，新增无需改旧类 | 产品种类多，需支持扩展             |
| 抽象工厂模式 | 创建多个关联产品（产品族）               | 保证系列产品一致性，如整套 UI 组件 |
