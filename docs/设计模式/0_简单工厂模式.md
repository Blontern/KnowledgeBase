## 背景故事

搬新家了！为了精进编程能力，你选择入住`面向对象社区`。

搬家自然少不了新家具，没门可不行，现在你有两种选择来获取一扇门：

- 🛠**自己制作**：每次需要都要手动创建对象，重复工作多。
- 🏭**委托工厂**：只需提供参数，工厂即可交付成品。

从“自己动手”到“工厂交付”，这正体现了简单工厂模式的核心思想 —— **将对象的创建与使用解耦**。

## 代码演示

1. 定义抽象产品类

```cs [抽象产品]
public abstract class DoorBase
{
    protected float width;
    protected float height;
    protected bool isOpen = false;

    public DoorBase(float width, float height)
    {
        this.width = width;
        this.height = height;
    }
    public abstract void Open();
    public abstract void Close();
}
```

2. 具体产品类：木门与铁门

```cs [具体产品]
public class WoodenDoor : DoorBase
{
    public WoodenDoor(float width, float height) : base(width, height) { }

    public override void Open()
    {
        isOpen = true;
        Console.WriteLine($"尺寸{width}x{height}的木门打开了！");
    }

    public override void Close()
    {
        isOpen = false;
        Console.WriteLine("木门关闭了！");
    }
}

public class IronDoor : DoorBase
{
    public IronDoor(float width, float height) : base(width, height) { }
    public override void Open()
    {
        isOpen = true;
        Console.WriteLine($"尺寸{width}x{height}的铁门打开了！");
    }
    public override void Close()
    {
        isOpen = false;
        Console.WriteLine("铁门关闭了！");
    }
}
```

3. 客户端对比

传统方式：客户端直接创建实例（耦合严重）

```cs [客户端]
// 每种门都需手动导入，耦合度高
using WoodenDoor;
using IronDoor;
// using 肛门
// using 金门
// using 钻石门
// using 下界合金门
static void Main(string[] args)
{
    WoodenDoor myWoodenDoor = new WoodenDoor(80, 200);
    myWoodenDoor.Open();

    IronDoor myIronDoor = new IronDoor(100, 220);
    myIronDoor.Open();
}
```

引入工厂类：统一创建入口，解耦客户端

```cs [工厂]
using WoodenDoor;
using IronDoor;
// using 肛门
// using 金门
// using 钻石门
// using 下界合金门
public static class DoorFactory
{
    public static DoorBase CreateDoor(string doorType, float width, float height)
    {
        switch (doorType.ToLower())
        {
            case "wooden":
                return new WoodenDoor(width, height);
            case "iron":
                return new IronDoor(width, height);
            default:
                throw new ArgumentException("不支持的门的类型");
        }
    }
}
```

```cs [客户端(使用工厂)]
using WoodenDoor; // [!code --]
using IronDoor; // [!code --]
// using 肛门 // [!code --]
// using 金门 // [!code --]
// using 钻石门 // [!code --]
// using 下界合金门 // [!code --]
using DoorFactory;  // 客户端仅需要了解工厂类[!code ++]
static void Main(string[] args)
{
    DoorBase door1 = DoorFactory.CreateDoor("wooden", 90, 210);
    door1.Open();

    DoorBase door2 = DoorFactory.CreateDoor("iron", 110, 230);
    door2.Open();
}
```

客户端只依赖工厂，无需了解产品类细节，实现了依赖反转。

## 定义

> **简单工厂模式（Simple Factory）**：又称**静态工厂方法模式**，通过一个工厂类根据参数决定实例化哪个具体产品类，对客户端屏蔽对象创建的细节，对外提供统一的创建接口。

> [!Warning]
> 严格来说，并不属于 GoF 23 种经典设计模式之一，但因其实用性高、结构简单，广泛作为入门首选。

简单工厂模式由三部分组成：抽象类产品(Product)、具体产品(ProductA、ProductB…)、工厂(Factory)。

| 角色     | 作用                   | 客户端是否可见 |
| -------- | ---------------------- | -------------- |
| 抽象产品 | 定义产品公共接口(可选) | 不可见         |
| 具体产品 | 实现抽象产品的具体类   | 不可见         |
| 工厂     | 创建产品的核心逻辑     | 可调用         |

<import filepath="./UML/0.puml" />

## 应用场景

**场景 1**：计算器开发，包含加、减、乘、除等二元运算。
**场景 2**：UI 主题切换，根据用户选择生成暗黑/明亮等主题包，客户端无需知道主题组件的构建细节。
**场景 3**：文件解析系统，根据扩展名(.json/.yaml/.xml)返回对应解析器，统一处理不同格式文件。
**场景 4**：数据库访问抽象，按配置创建 MySQL/MongoDB 连接对象，业务代码不依赖具体数据库实现。

## 总结

优点

- 不直接在客户端创建具体产品的实例，降低了耦合性。

缺点

- 违反了[开闭原则](./-1_编程原则.md#一-核心设计原则)（对扩展开放，对修改关闭），每当我们增加一种产品的时候就要去修改工厂方法，这样会破坏其内聚性，给维护带来额外开支。

简单工厂模式适用于**产品种类固定，变化频率低**的场景，核心价值在于：

- 封装对象创建过程
- 隔离客户端与具体产品
- 统一入口管理对象创建

当系统需要频繁新增产品类型时，应考虑使用 **工厂方法模式** 以增强扩展性。

| 相关模式     | 特点                                     | 适用场景                           |
| ------------ | ---------------------------------------- | ---------------------------------- |
| 简单工厂模式 | 工厂类内部判断创建逻辑，新增需改代码     | 产品种类少，变化频率低             |
| 工厂方法模式 | 每种产品对应一个子工厂类，新增无需改旧类 | 产品种类多，需支持扩展             |
| 抽象工厂模式 | 创建多个关联产品（产品族）               | 保证系列产品一致性，如整套 UI 组件 |
