## 背景故事

假设你在开发一款大型 RPG 游戏，需要生成大量相似NPC，他们名字和服装颜色稍有变化。

如果每次创建都重新初始化，将消耗大量资源。这时我们可以借助原型模式：通过**复制已有对象**来快速生成相同配置的新实例，就像在用复印机。

## 代码演示

1. 抽象原型类（接口）

```cs
public interface IPrototype<T>
{
    T Clone(); // 复制自身
}

```

2. 具体原型类

```cs
public class Character : IPrototype<Character>
{
    public string Name { get; set; }
    public string Class { get; set; }
    public List<string> Skills { get; set; } = new List<string>();

    public Character Clone()
    {
        return new Character
        {
            Name = this.Name,
            Class = this.Class,
            Skills = new List<string>(this.Skills) // 深拷贝
        };
    }

    public void Show()
    {
        Console.WriteLine($"{Name} - 职业: {Class} - 技能: {string.Join(",", Skills)}");
    }
}

```

3. 客户端使用原型创建新对象

```cs
var warriorPrototype = new Character
{
    Name = "模板·战士",
    Class = "Warrior",
    Skills = new List<string> { "旋风斩", "盾击" }
};

var player1 = warriorPrototype.Clone();
player1.Name = "电脑玩家A";

var player2 = warriorPrototype.Clone();
player2.Name = "电脑玩家B";
player2.Skills.Add("怒吼");

player1.Show(); // 玩家A - 职业: Warrior - 技能: 旋风斩,盾击
player2.Show(); // 玩家B - 职业: Warrior - 技能: 旋风斩,盾击,怒吼

```

> [!tip]
> `Skills` 做了深拷贝，避免多个实例共享引用，防止数据污染。

<import filepath="./UML/5.puml" />

### 优化

> 如何优化深拷贝性能？  
> 答案：使用序列化/反序列化（如`BinaryFormatter`）或表达式树编译动态拷贝方法

## 定义

> **原型模式（Prototype）**：核心思想是“**克隆现有对象**”而非新建，用原型实例指定创建对象的种类，并通过**复制这个原型**来创建新的对象。

| 角色       | 作用                    |
| -------- | --------------------- |
| **原型接口** | 声明克隆方法（如`ICloneable`） |
| **具体原型** | 实现克隆逻辑（深拷贝/浅拷贝）       |
| **客户端**  | 调用原型对象的克隆方法创建新实例      |

通常，编程语言会提供克隆方法。

#### **拷贝类型对比**

|类型|特点|原型模式适用性|
|---|---|---|
|**浅拷贝**|复制值类型+引用指针（共享引用对象）|低（易副作用）|
|**深拷贝**|完全独立副本（包括嵌套引用）|高（推荐实现）|
## 应用场景

当创建一个对象的代价很大时，通过现有对象克隆一个新的对象更为高效，比如：
- 大量NPC或怪物的角色创建
- 很复杂的UI组件或UI组件树
- 对象结构复杂但变化点集中

## 总结

**优点**
- **提高效率**：通过克隆减少重复初始化，提高对象创建性能；
- **简化创建**：隐藏复杂构造逻辑，客户端只需调用 `Clone()`；
- **运行时动态创建**：可动态选择原型对象，不依赖具体类名或构造参数。

**缺点**
- **深拷贝处理复杂**：对象中存在引用类型时需手动处理深/浅拷贝问题；
- **类结构复杂时不易维护**：大量嵌套或循环引用对象可能导致克隆逻辑冗长，甚至无限递归；
- **导致数据污染**：浅拷贝容易造成多实例共享同一引用。
- **破坏封装性**：需暴露字段供克隆访问