## 背景故事

假设你正在开发一款塔防游戏，其中敌人具有不同的移动策略：

- 沿最短路径前进（最短路）
- 避开炮塔区域（安全路）
- 随机移动（扰乱 AI）

如果你在敌人类中写死这些逻辑：

```cs
switch (strategy)
{
    case "shortest": MoveAlongShortestPath(); break;
    case "safe": MoveSafelyAvoidingTowers(); break;
    case "random": MoveRandomly(); break;
}
```

问题显而易见：

- 增加新策略 → 修改敌人类，违背开闭原则
- 策略逻辑杂糅于核心类 → 不利于复用和维护

策略模式通过将每种策略封装为独立类，允许在运行时灵活切换行为，彻底解耦行为逻辑。

## 代码演示

接口

```cs
public interface IMoveStrategy
{
    void Move();
}
```

```cs
public class ShortestPathStrategy : IMoveStrategy
{
    public void Move() => Console.WriteLine("沿最短路径前进");
}

public class SafePathStrategy : IMoveStrategy
{
    public void Move() => Console.WriteLine("避开炮塔区域前进");
}

public class RandomPathStrategy : IMoveStrategy
{
    public void Move() => Console.WriteLine("敌人在地图中随机移动");
}
```

```cs
public class Enemy
{
    private IMoveStrategy strategy;

    public Enemy(IMoveStrategy strategy)
    {
        this.strategy = strategy;
    }

    public void SetStrategy(IMoveStrategy strategy)
    {
        this.strategy = strategy;
    }

    public void Move()
    {
        strategy.Move();
    }
}
```

```cs
var enemy = new Enemy(new ShortestPathStrategy());
enemy.Move(); // 沿最短路径前进

enemy.SetStrategy(new RandomPathStrategy());
enemy.Move(); // 敌人随机移动
```

## 定义

**策略模式（Strategy）**：定义一系列可互换的算法，将每个算法封装起来，并使它们可以相互替换，使算法的变化独立于使用它的客户。

<import filepath="./UML/21.puml" />

## 应用场景

|场景|示例|
|---|---|
|AI 决策系统|攻击/防御/逃跑 策略自由切换|
|缓存替换算法|FIFO/LRU/LFU 等策略统一封装|
|排序规则|封装多种排序算法，如快速排序/归并排序|
|支付系统|切换不同支付策略（微信/支付宝/银行卡）|
|日志格式化/压缩策略|封装多种日志存储或格式化方式|

## 总结

**优点**

- 完全遵守开闭原则，新增策略无需修改上下文类
- 支持运行时切换算法，灵活应对需求变化
- 策略类可复用，可单元测试

**缺点**

- 策略类数量可能激增（每个策略一个类）
- 客户端必须理解每种策略的差异，否则使用错误可能带来问题