## 背景故事

你正在开发一个背包系统，需要遍历其中的所有物品。直接暴露 `List<Item>` 会让客户端依赖背包内部结构，未来若更换容器（如栈、链表）将影响客户端代码。

理想方案是：**对外提供统一遍历接口，而隐藏集合内部实现** —— 这正是**迭代器模式**的设计动机。

## 定义

> **迭代器模式（Iterator）**：提供一种方法，顺序访问一个聚合对象中的元素，而不暴露其内部结构。

### 现代语言的内置迭代器支持

|语言|内置特性|
|---|---|
|**C#**|`IEnumerable<T>` / `foreach`|
|**Java**|`Iterator` 接口 / 增强 for-each|
|**Python**|`__iter__()` / `for x in obj:`|
|**Rust**|`impl Iterator` + `.next()`|
|**C++**|STL 容器迭代器 (`begin()`, `end()`)|

你几乎无需手动实现迭代器，只需实现语言接口即可。

## 应用场景

- 集合类（List、Map、Tree）需要向外提供遍历能力
- 客户端不应依赖集合内部结构
- 支持多种遍历方式（正序、逆序、分页、过滤等）

## 总结

迭代器模式的**核心价值在于解耦遍历算法与集合结构**，在现代语言中已高度抽象：

- 保证集合对象结构封装性
- 支持灵活遍历策略（如分页、过滤）
- 已内置于主流语言中，开发者只需使用现成接口

> [!tip]
> 实际开发中，除非构建自定义数据结构或非标准遍历逻辑，一般无需手动实现迭代器模式。