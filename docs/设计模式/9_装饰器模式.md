## 背景故事

你正在开发一个文本编辑器，已经实现了基础的文本渲染器 `ITextRenderer`：

```cs
public interface ITextRenderer
{
    void Render(string text);
}

```

现在，你的产品经理要求支持以下功能：

- 文本加粗
- 文本加颜色
- 文本加边框
- 同时加粗+加边框
- 同时加粗+加颜色
- 同时加边框+加颜色
- 同时加粗+加边框+加颜色……

如果你选择继承：

```cs
class BoldTextRenderer : ITextRenderer { ... }
class ColoredTextRenderer : ITextRenderer { ... }
class BorderedColoredBoldTextRenderer : ITextRenderer { ... } 
// 啊好多……我不想写了
```

我们会发现以下这些**问题**：

1. **类爆炸**：排列组合导致子类数量指数增长
2. **僵化扩展**：新增配料需修改所有组合类
3. **运行时限制**：无法动态添加/移除配料

装饰器模式应运而生，它允许你**动态地为对象添加功能，而无需修改原类或创建子类**，就像功能的动态包装纸。

## 代码演示

1. 抽象组件

```cs
public interface ITextRenderer
{
    void Render(string text);
}
```

2. 具体组件（被装饰对象）

```cs
public class PlainTextRenderer : ITextRenderer
{
    public void Render(string text)
    {
        Console.WriteLine($"显示文本: {text}");
    }
}

```

3. 抽象装饰器（实现接口，持有组件引用）

```cs
public abstract class TextRendererDecorator : ITextRenderer
{
    protected ITextRenderer _inner;

    public TextRendererDecorator(ITextRenderer inner)
    {
        _inner = inner;
    }
    public abstract void Render(string text);
}

```

4. 具体装饰器

```cs
public class BoldDecorator : TextRendererDecorator
{
    public BoldDecorator(ITextRenderer inner) : base(inner) { }

    public override void Render(string text)
    {
        Console.WriteLine("【加粗开始】");
        _inner.Render(text);
        Console.WriteLine("【加粗结束】");
    }
}

public class BorderDecorator : TextRendererDecorator
{
    public BorderDecorator(ITextRenderer inner) : base(inner) { }

    public override void Render(string text)
    {
        Console.WriteLine("┌──────────┐");
        _inner.Render(text);
        Console.WriteLine("└──────────┘");
    }
}
```

5. 客户端调用

```cs
static void Main()
{
    ITextRenderer plain = new PlainTextRenderer();
    ITextRenderer bold = new BoldDecorator(plain);
    ITextRenderer bordered = new BorderDecorator(bold);
    bordered.Render("Hello Decorator!");
}

```

## 定义

> **装饰器模式（Decorator）**：在不改变原有对象结构的情况下，**动态扩展对象功能**，通过创建装饰类将原始对象“包装”起来，从而增加额外行为。

<import filepath="./UML/9.puml" />

## 应用场景

1. 动态添加职责，比继承更加灵活。
2. 无法使用继承的场景（如密封类）
3. 撤销功能（通过移除装饰器）

> **思考题**：  
> 如何实现装饰器的撤销功能？  
> 答案：维护装饰器链表，移除指定层装饰器。

## 总结

**优点**
- **动态扩展**：运行时添加/移除功能
- **避免类爆炸**：无需为每种组合创建子类

**缺点**
- **多层嵌套**：过度使用导致代码复杂（如`new D3(new D2(new D1(new Base())))`）