## 背景故事

在开发一个任务调度系统时，你发现某些关键组件必须**全局唯一**。例如：

- 日志服务若被多次实例化，可能会**并发写入同一文件**导致崩溃；
- 配置加载器若被重复创建，会导致**内存中存在多个配置副本**，最终行为不可预测。

为避免此类问题，需要一种机制保证这些组件在系统中**只存在一个实例**，并能全局访问。**单例模式**正是为此而生。

你可能会问：**为什么不直接用静态类？**

虽然静态类也能实现全局访问，但存在本质缺陷：

| 特性           | 单例模式               | 静态类                |
| -------------- | ---------------------- | --------------------- |
| **接口实现**   | ✅ 支持多态            | ❌ 不能实现接口       |
| **延迟初始化** | ✅ 精确控制创建时机    | ❌ 类加载时自动初始化 |
| **状态管理**   | ✅ 私有成员变量        | ❌ 仅静态变量         |
| **继承能力**   | ✅ 可被继承            | ❌ 不能继承           |
| **内存释放**   | ✅ 可实现`IDisposable` | ❌ 程序结束前无法释放 |
| **依赖注入**   | ✅ 可注册到 DI 容器    | ❌ 无法注入           |

因此，单例不仅是“**唯一实例**”，也是更适合现代架构（如依赖注入/接口编程）的选择。

## 代码演示

<import filepath="./UML/3.puml" />

1. 饿汉式

```cs [饿汉式]
public sealed class ResourceManager
{
    // 类加载时立即创建实例
    private static readonly ResourceManager _instance = new ResourceManager();

    // 私有构造函数防止外部实例化
    private ResourceManager()
    {
        Console.WriteLine("ResourceManager 饿汉式实例已创建");
    }

    // 全局访问点
    public static ResourceManager Instance => _instance;

    // 示例方法
    public void LoadResource(string resourceName)
    {
        Console.WriteLine($"加载资源: {resourceName}");
    }
}
```

2. 懒汉式

```cs [懒汉式]
public sealed class ResourceManager
{
    private static ResourceManager? _instance;
    private static readonly object _lock = new object();

    private ResourceManager()
    {
        Console.WriteLine("ResourceManager 懒汉式实例已创建");
    }

    public static ResourceManager Instance
    {
        get
        {
			return _instance ??= new ResourceManager();
        }
    }

    public void LoadResource(string resourceName)
    {
        Console.WriteLine($"加载资源: {resourceName}");
    }
}
```

3. 懒汉模式-双重检查锁

```cs [懒汉模式-双重检查锁]
public sealed class ResourceManager
{
    // volatile确保多线程可见性
    private static volatile ResourceManager? _instance;
    private static readonly object _lock = new object();

    private ResourceManager()
    {
        Console.WriteLine("ResourceManager DCL实例已创建");
    }

    public static ResourceManager Instance
    {
        get
        {
            // 第一重检查：避免不必要的锁定
            if (_instance == null)
            {
                lock (_lock)
                {
                    // 第二重检查：确保只创建一次
                    if (_instance == null)
                    {
                        _instance = new ResourceManager();
                    }
                }
            }
            return _instance;
        }
    }

    public void LoadResource(string resourceName)
    {
        Console.WriteLine($"加载资源: {resourceName}");
    }
}
```

4. 单例类`C# .NET 8`推荐实现

```cs
public sealed class ResourceManager
{
    // Lazy<T>提供线程安全的延迟初始化
    private static readonly Lazy<ResourceManager> _lazyInstance =
        new Lazy<ResourceManager>(() => new ResourceManager());

    private ResourceManager()
    {
        Console.WriteLine("ResourceManager Lazy实例已创建");
    }

    public static ResourceManager Instance => _lazyInstance.Value;

    public void LoadResource(string resourceName)
    {
        Console.WriteLine($"加载资源: {resourceName}");
    }
}
```

客户端

```cs [客户端]
class Program
{
    static void Main()
    {
        // 获取单例实例
        var manager = ResourceManager.Instance;

        // 使用资源管理器
        manager.LoadResource("GlobalConfig");
        manager.LoadResource("DatabaseConnection");

        // 验证是否为单例
        var anotherRef = ResourceManager.Instance;
        Console.WriteLine($"实例相同: {ReferenceEquals(manager, anotherRef)}");
    }
}
```

## 定义

> **单例模式（Singleton）** ：确保一个类**仅有一个实例**，并提供一个**全局访问点**来获取该实例，同时禁止外部直接实例化。

单例模式的核心是：

- **构造器私有化**（阻止外部构造）
- **提供静态访问方法**（返回单个实例）
- **控制实例创建逻辑**

虽然单例模式仅有一个类，但这个模式也有不同变体。

| 变体                  | 特点与适用场景                                                               |
| --------------------- | ---------------------------------------------------------------------------- |
| **饿汉式**            | 类加载即创建实例，线程安全，适合小对象，但可能浪费资源（若实例最终未被使用） |
| **懒汉式**            | 延迟加载，首次调用时才创建实例，线程不安全（需加锁）                         |
| **双重检查锁（DCL）** | 延迟加载 + 并发优化，双重检查避免重复加锁，适合多线程场景                    |

<import filepath="./UML/3_0.puml" />

## 应用场景

单例模式适用于需要**保证系统唯一性**的全局服务组件：

- **资源管理器**  
  数据库连接池、线程池、缓存服务等资源密集型组件，通过单例确保资源复用和统一管理
- **日志系统**  
   多模块共享同一日志实例，避免并发写入冲突，保证日志顺序一致性
- **配置加载器**  
   全局配置信息只需加载一次，确保内存中配置状态唯一
- **应用状态机**  
   用户会话状态、系统运行状态等需要全局一致性的状态管理

## 总结

**优点**

- **节省资源**：避免重复创建大型对象（如数据库连接）
- **全局访问**：通过静态接口统一访问实例
- **可控初始化**：支持延迟加载或依赖注入
- **易于扩展**：可继承、可实现接口、可参与 IoC 框架

**缺点**

- **潜在的全局状态污染**：所有代码共享一个实例，若未管理好状态，易引发隐式耦合
- **不利于测试**：不能通过构造函数注入替身对象，需使用接口 + mock 构造辅助测试
- **并发访问风险**：懒汉式必须处理线程同步问题，否则会产生多实例
