## 背景故事

假设你在开发一款编译器或抽象语法树（AST）分析器。该系统包含多种节点类型：

- 变量声明节点（VariableNode）
- 函数定义节点（FunctionNode）
- 表达式节点（ExpressionNode）等

不同场景中，你可能要对这些节点执行不同操作：

- 语法检查
- 代码生成
- 性能分析
- 变量统计
- ……

一种做法是：在每个节点类中加入这些方法。但这样会导致：

- 每新增一种操作，就得**修改所有节点类**，违反开闭原则；
- 节点类职责混乱，维护困难；

此时，访问者模式允许你**将操作行为从数据结构中分离出来**，每个访问者专注于一种操作，让节点“接受访问”即可。

## 代码演示

```cs
public interface INode
{
    void Accept(INodeVisitor visitor);
}
```

```cs
public class VariableNode : INode
{
    public string Name = "x";
    public void Accept(INodeVisitor visitor) => visitor.Visit(this);
}

public class FunctionNode : INode
{
    public string FunctionName = "main";
    public void Accept(INodeVisitor visitor) => visitor.Visit(this);
}
```

```cs
public interface INodeVisitor
{
    void Visit(VariableNode node);
    void Visit(FunctionNode node);
}
```

```cs
public class SyntaxChecker : INodeVisitor
{
    public void Visit(VariableNode node) 
        => Console.WriteLine($"检查变量定义: {node.Name}");

    public void Visit(FunctionNode node) 
        => Console.WriteLine($"检查函数定义: {node.FunctionName}");
}
```

```cs
var nodes = new List<INode> { new VariableNode(), new FunctionNode() };
var checker = new SyntaxChecker();

foreach (var node in nodes)
    node.Accept(checker);
```

## 定义

**访问者模式（Visitor）**：在不改变元素类结构的前提下，**定义作用于这些元素的新操作**。通过将操作行为封装为“访问者”，将算法与对象解耦。

<import filepath="./UML/23.puml" />

## 应用场景

|应用类型|示例|
|---|---|
|语法树处理|编译器、代码生成器、语法分析器|
|报表系统|企业对象结构复杂，访问者可用于生成报表、导出等|
|UI 元素渲染|多种组件（按钮、图标、标签），访问者渲染逻辑分离|
|游戏事件系统|对不同游戏角色或物品执行不同操作|

## 总结

**优点**

- **符合开闭原则**：元素结构稳定，新增操作时只需添加访问者类
- **职责清晰**：数据与操作解耦，代码维护性强
- **支持多重操作**：多个访问者可在不修改元素类的前提下叠加功能

**缺点**

- 元素类型频繁变化时，需要同步修改所有访问者（破坏扩展性）
- 依赖“双重分发”机制（接口设计复杂）
- 会产生大量访问者和元素类，结构稍显笨重
